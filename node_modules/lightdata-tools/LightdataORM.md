# ğŸ§¬ **LightdataORM â€” ORM GenÃ©rico Versionado para LightData**

`LightdataORM` es una clase ORM avanzada diseÃ±ada para simplificar y estandarizar las operaciones **CRUD versionadas** (`superado`, `elim`) en el ecosistema **LightData**.  
Incluye manejo de batch, versionado histÃ³rico, trazabilidad con `quien`, y construcciÃ³n automÃ¡tica de clÃ¡usulas `WHERE`.

---

## ğŸš€ CaracterÃ­sticas principales

| ğŸ§© CaracterÃ­stica | DescripciÃ³n |
|------------------|-------------|
| ğŸ§¬ **Versionado automÃ¡tico** | Cada `update` o `delete` crea una nueva versiÃ³n manteniendo el histÃ³rico. |
| ğŸ§± **WHERE dinÃ¡mico** | Acepta objetos `{ campo: valor }` o arrays `{ campo: [1,2,3] }` â†’ `IN (...)`. |
| âš¡ **Batch nativo** | Inserta, actualiza o elimina mÃºltiples registros en una sola query. |
| ğŸ¦¾ **Trazabilidad** | Incluye automÃ¡ticamente el campo `quien` en todas las operaciones. |
| ğŸ” **Consistencia total** | Misma estructura y sintaxis en los 4 mÃ©todos (`select`, `insert`, `update`, `delete`). |
| ğŸ§  **Errores coherentes** | Usa `CustomException` con `Status` uniforme para todas las operaciones. |

---

## ğŸ“˜ **1ï¸âƒ£ SELECT â€” Obtener registros vigentes**

```js
// âœ… Buscar variante por DID
const variante = await LightdataORM.select({
  db,
  table: "variantes",
  where: { did: 42 },
  throwIfNotExists: true, // Lanza 404 si no existe
});

console.log(variante[0]);

// âœ… Buscar cliente por nombre y empresa
const clientes = await LightdataORM.select({
  db,
  table: "clientes",
  where: { empresa_id: 5, nombre: "HappyHouse" },
});

// âœ… Buscar varios registros usando IN
const variantes = await LightdataORM.select({
  db,
  table: "variantes",
  where: { did: [1, 2, 3], empresa_id: 12 },
});
```

### ğŸ“— QuÃ© hace:
- Filtra automÃ¡ticamente por `superado = 0 AND elim = 0`
- Permite mÃºltiples condiciones y arrays (`IN (...)`)
- Devuelve solo registros vigentes
- Puede lanzar `CustomException` si:
  - `throwIfExists = true` â†’ existe duplicado
  - `throwIfNotExists = true` â†’ no hay coincidencias

---

## âš™ï¸ **2ï¸âƒ£ INSERT â€” Alta de registros**

```js
// âœ… Insertar una sola variante
const insertedIds = await LightdataORM.insert({
  db,
  table: "variantes",
  data: {
    codigo: "VAR-RED",
    nombre: "Color rojo",
    descripcion: "Variante de color primario",
  },
  quien: userId,
});

console.log("Nueva variante:", insertedIds);

// âœ… Insertar mÃºltiples categorÃ­as
const newCats = await LightdataORM.insert({
  db,
  table: "variantes_categorias",
  data: [
    { did_variante: 42, nombre: "TamaÃ±o" },
    { did_variante: 42, nombre: "Color" },
    { did_variante: 42, nombre: "Material" },
  ],
  quien: userId,
});
```

### ğŸ“— QuÃ© hace:
- Inserta mÃºltiples filas en una sola query batch
- Ajusta automÃ¡ticamente `did = id`
- AÃ±ade los valores por defecto:
  - `superado = 0`
  - `elim = 0`
  - `quien` = usuario actual
- Devuelve los **IDs/DIDs insertados**

---

## ğŸ§© **3ï¸âƒ£ UPDATE â€” Versionado automÃ¡tico**

```js
// âœ… Actualizar una sola variante
await LightdataORM.update({
  db,
  table: "variantes",
  where: { did: 42 },
  data: { nombre: "Color rojo brillante", habilitado: 1 },
  quien: userId,
});

// âœ… Actualizar mÃºltiples categorÃ­as (batch)
await LightdataORM.update({
  db,
  table: "variantes_categorias",
  where: { did: [11, 12, 13] },
  data: [
    { nombre: "TamaÃ±o actualizado" },
    { nombre: "Color actualizado" },
    { nombre: "Material actualizado" },
  ],
  quien: userId,
});
```

### ğŸ“— QuÃ© hace:
- Marca las versiones previas (`superado = 1`)
- Inserta nuevas versiones con los cambios
- Mantiene el mismo `did` para el histÃ³rico
- Permite operaciones por lote (`CASE WHEN` dinÃ¡mico)

### ğŸ“˜ Notas tÃ©cnicas:
| Caso | Comportamiento |
|------|----------------|
| `data` es un objeto simple | Aplica los mismos cambios a todos los `did` |
| `data` es un array | Aplica cambios especÃ­ficos a cada registro (`CASE WHEN`) |

---

## ğŸ—‘ï¸ **4ï¸âƒ£ DELETE â€” EliminaciÃ³n lÃ³gica versionada**

```js
// âœ… Eliminar (soft delete) una categorÃ­a
await LightdataORM.delete({
  db,
  table: "variantes_categorias",
  where: { did: 11 },
  quien: userId,
});

// âœ… Eliminar varias categorÃ­as en batch
await LightdataORM.delete({
  db,
  table: "variantes_categoria_valores",
  where: { did: [101, 102, 103], empresa_id: 12 },
  quien: userId,
});
```

### ğŸ“— QuÃ© hace:
- Marca versiones previas como `superado = 1`
- Inserta nuevas versiones con `elim = 1`
- Mantiene la trazabilidad (`quien`, `autofecha`, etc.)
- Soporta filtros mÃºltiples y arrays (`IN (...)`)

---

## âš’ï¸ **5ï¸âƒ£ buildWhereClause â€” ConstrucciÃ³n dinÃ¡mica de WHERE**

```js
const { sql, params } = LightdataORM.buildWhereClause({
  did: [1, 2, 3],
  empresa_id: 12,
});

console.log(sql);    // did IN (?, ?, ?) AND empresa_id = ?
console.log(params); // [1, 2, 3, 12]
```

### ğŸ“— QuÃ© hace:
- Convierte cualquier objeto JS en una clÃ¡usula SQL segura
- Compatible con arrays (`IN`) y mÃºltiples condiciones (`AND`)
- Devuelve `{ sql, params }` listo para `executeQuery`
- Se usa internamente por `select`, `update` y `delete`

---

## ğŸ§¾ **Resumen rÃ¡pido**

| MÃ©todo | PropÃ³sito | Soporta batch | Versiona (`superado`) | Auto `did=id` | Auto `quien` | Usa `buildWhereClause` |
|---------|------------|---------------|-----------------------|----------------|---------------|-------------------------|
| `select` | Obtener registros vigentes | âœ… | âŒ | âŒ | âŒ | âœ… |
| `insert` | Alta simple o mÃºltiple | âœ… | âŒ | âœ… | âœ… | âŒ |
| `update` | Versionado de datos | âœ… | âœ… | âŒ | âœ… | âœ… |
| `delete` | EliminaciÃ³n lÃ³gica versionada | âœ… | âœ… | âŒ | âœ… | âœ… |

---

## ğŸ§© **Ejemplo completo**

```js
// Crear una nueva variante
const [didVariante] = await LightdataORM.insert({
  db,
  table: "variantes",
  data: { codigo: "VAR-AZUL", nombre: "Color azul" },
  quien: userId,
});

// Agregar categorÃ­as relacionadas
await LightdataORM.insert({
  db,
  table: "variantes_categorias",
  data: [
    { did_variante: didVariante, nombre: "TamaÃ±o" },
    { did_variante: didVariante, nombre: "Material" },
  ],
  quien: userId,
});

// Modificar la descripciÃ³n (versionado)
await LightdataORM.update({
  db,
  table: "variantes",
  where: { did: didVariante },
  data: { descripcion: "Color azul oscuro" },
  quien: userId,
});

// Eliminar lÃ³gicamente una categorÃ­a
await LightdataORM.delete({
  db,
  table: "variantes_categorias",
  where: { did: [1] },
  quien: userId,
});
```

---

## âœ… **Buenas prÃ¡cticas recomendadas**

1. ğŸ—¾ **Usar siempre el campo `quien`**  
   Permite rastrear quiÃ©n realizÃ³ cada acciÃ³n.

2. ğŸ¥¥ **Evitar deletes fÃ­sicos**  
   Siempre usar `LightdataORM.delete()` para mantener histÃ³rico.

3. âš¡ **Aprovechar los batch**  
   Insertar, actualizar o eliminar mÃºltiples registros con arrays es mÃ¡s eficiente.

4. ğŸ”’ **Usar `throwIfNotExists` en lecturas crÃ­ticas**  
   Evita operaciones sobre registros inexistentes.

5. ğŸ§© **Combinar filtros compuestos**  
   Ejemplo:  
   ```js
   where: { did: [1,2,3], empresa_id: 12, tipo: "activo" }
   ```