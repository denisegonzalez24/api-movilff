import crypto from 'node:crypto';

// Helpers base
export const pick = (v) => (Array.isArray(v) ? v[0] : v);
const normalize = (v) =>
    String(pick(v) ?? '').trim().toLowerCase()
        .normalize('NFD').replace(/\p{Diacritic}/gu, ''); // quita tildes

// 0/1 desde string/bool/num
export const to01 = (v, def) => {
    const s = normalize(v);
    if (['true', '1', 'yes', 'si', 'on', 'y', 't'].includes(s)) return 1;
    if (['false', '0', 'no', 'off', 'n', 'f'].includes(s)) return 0;
    // acepta booleanos y números directos
    if (v === true) return 1;
    if (v === false) return 0;
    if (v === 0 || v === 1) return v;
    return def;
};

// Boolean “real”
export const toBoolean = (v, def) => {
    const r = to01(v, def === undefined ? undefined : (def ? 1 : 0));
    return r === 1 ? true : r === 0 ? false : def;
};

// Mantén la firma antigua si te sirve (redirige)
export const toBool = (v, def) => to01(v, def);      // 0/1
export const toBool01 = (v, def) => to01(v, def);    // alias

export const toStr = (v) => {
    const s = pick(v);
    if (s === undefined || s === null) return undefined;
    const t = String(s).trim();
    return t.length ? t : undefined;
};

// Entero estricto (sin parseos parciales)
export const toInt = (v, def) => {
    const s = String(pick(v) ?? '').trim();
    if (/^-?\d+$/.test(s)) return Number(s);
    return def;
};

export const toIntList = (v) => {
    if (v === undefined || v === null) return undefined;

    // Unificar en array y split por comas
    const parts = (Array.isArray(v) ? v : String(v).split(','))
        .flatMap((p) => String(p).split(','))
        .map((s) => s.trim())
        .filter((s) => /^-?\d+$/.test(s)) // estricto
        .map(Number);

    const nums = Array.from(new Set(parts)); // únicos, conserva orden
    return nums.length ? nums : undefined;
};

export const isDefined = (v) => v !== undefined && v !== null;

export const isNonEmpty = (v) => {
    if (!isDefined(v)) return false;
    if (typeof v === 'string') return v.trim() !== '';
    if (Array.isArray(v)) return v.length > 0;
    if (typeof v === 'object') return Object.keys(v).length > 0;
    return true; // números, booleanos, etc.
};

export const number01 = (v) => {
    if (v === true) return 1;
    if (v === false) return 0;
    const n = Number(v);
    if (Number.isNaN(n)) return -1;
    return n === 1 ? 1 : n === 0 ? 0 : -1;
};

export function pickNonEmpty(obj) {
    const out = {};
    for (const [k, v] of Object.entries(obj)) {
        if (!isDefined(v)) continue;
        if (typeof v === 'string' && v.trim() === '') continue;
        if (Array.isArray(v) && v.length === 0) continue;
        if (typeof v === 'object' && !Array.isArray(v) && Object.keys(v).length === 0) continue;
        out[k] = v;
    }
    return out;
}

// Escapar para LIKE ... ESCAPE '\\'
export const escapeLike = (s) =>
    String(s)
        .replace(/\\/g, '\\\\')
        .replace(/%/g, '\\%')
        .replace(/_/g, '\\_');

export const isNonEmptyString = (v) => typeof v === 'string' && v.trim() !== '';

export const emptyToNull = (v) => (typeof v === 'string' && v.trim() === '' ? null : v);

// ⚠️ NO usar para contraseñas
export const sha256 = (s) => crypto.createHash('sha256').update(String(s)).digest('hex');

// ✅ Password hashing recomendado (sin deps): scrypt
export const hashPassword = async (plain) => {
    const salt = crypto.randomBytes(16);
    const derivedKey = await new Promise((res, rej) =>
        crypto.scrypt(String(plain), salt, 64, (err, dk) => (err ? rej(err) : res(dk)))
    );
    return `${salt.toString('hex')}$${Buffer.from(derivedKey).toString('hex')}`;
};

export const verifyPassword = async (plain, stored) => {
    const [alg, ver, saltHex, keyHex] = String(stored).split('$');
    if (alg !== 'scrypt' || ver !== '1') return false;
    const salt = Buffer.from(saltHex, 'hex');
    const key = Buffer.from(keyHex, 'hex');
    const derivedKey = await new Promise((res, rej) =>
        crypto.scrypt(String(plain), salt, 64, (err, dk) => (err ? rej(err) : res(dk)))
    );
    return crypto.timingSafeEqual(key, Buffer.from(derivedKey));
};
export const isInt = v => v !== undefined && /^\d+$/.test(String(v));

export const parseIdList = (val) => {
    if (!val) return [];
    if (Array.isArray(val)) return [...new Set(val.map(String))].filter(isInt).map(Number);
    if (typeof val === "string") return [...new Set(val.split(",").map(s => s.trim()))].filter(isInt).map(Number);
    return [];
};
