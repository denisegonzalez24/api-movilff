import { executeQuery } from "../db_functions/execute_querys/execute_query.js";
import { isDefined } from "../helpers/helpers.js";
import { CustomException } from "./custom_exception.js";
import { Status } from "./status.js";

/**
 * LightdataORM
 * ------------------------------------------------------------
 * ORM minimalista para CRUD **versionado** (campos `superado` / `elim`)
 * con validación de columnas contra INFORMATION_SCHEMA y SQL parametrizado.
 *
 * Ideas clave
 * - Versionado inmutable: los updates crean una nueva fila y marcan la previa como `superado=1`.
 * - `did` (o `versionKey`) identifica el hilo de versiones de un registro.
 * - `quien` siempre se rellena con el usuario llamante.
 * - Sin transacciones internas (deben manejarse por fuera si se necesitan).
 *
 * Requisitos
 * - `executeQuery({ db, query, values, log })` debe estar basado en promesas (mysql2/promise).
 *
 * Ejemplos rápidos
 * ```js
 * // SELECT vigente
 * await LightdataORM.select({ db, table: "pedidos", where: { did: 10 } });
 *
 * // INSERT (devuelve [ids] o, si returnRow=true y data único, el objeto insertado)
 * await LightdataORM.insert({ db, table: "depósitos", data: { codigo: "X" }, quien: 7 });
 *
 * // UPDATE versionado por did (batch o 1:1)
 * await LightdataORM.update({
 *   db, table: "clientes", where: { did: [11, 12] }, data: [{ nombre: "A" }, { nombre: "B" }], quien: 7
 * });
 *
 * // UPSERT: si existe según `where` → update por `versionKey`; si no → insert
 * await LightdataORM.upsert({
 *   db, table: "colecta_ruta", where: { fecha: "2025-11-12", didChofer: 73 }, data: {...}, quien: 73
 * });
 * ```
 */
export class LightdataORM {
    /** Caché de columnas por tabla */
    static _columnsCache = new Map();

    /* =========================
     * Utilidades internas
     * ========================= */
    static _assert(cond, { title, message, status = Status.badRequest }) {
        if (!cond) throw new CustomException({ title, message, status });
    }
    static _normalizeSelect(select) { return Array.isArray(select) ? select.join(", ") : (select ?? "*"); }
    static _quoteIdent(name) { return `\`${name}\``; }
    static _quoteTable(table) { return `\`${table}\``; }

    /**
     * Lee y cachea columnas válidas de una tabla.
     */
    static async _getTableColumns({ db, table, log = false }) {
        if (this._columnsCache.has(table)) return this._columnsCache.get(table);
        const sql = `
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_NAME = ? AND TABLE_SCHEMA = DATABASE();
    `;
        const rows = await executeQuery({ db, query: sql, values: [table], log });
        if (!rows?.length) {
            throw new CustomException({
                title: "LightdataORM.columns",
                message: `Tabla ${table} no encontrada en INFORMATION_SCHEMA`,
                status: Status.badRequest,
            });
        }
        const cols = rows.map(r => r.COLUMN_NAME);
        this._columnsCache.set(table, cols);
        return cols;
    }

    /**
     * Valida columnas contra INFORMATION_SCHEMA y permite excluir algunas.
     */
    static async _prepareColumns({ db, table, blocklist = [], log = false }) {
        const cols = await this._getTableColumns({ db, table, log });
        const set = new Set(cols);
        const validCols = cols.filter(c => !blocklist.includes(c));
        const ensure = (name) => {
            if (!set.has(name)) {
                throw new CustomException({
                    title: "LightdataORM.columns",
                    message: `Columna inválida "${name}" para tabla ${table}`,
                    status: Status.badRequest,
                });
            }
            return name;
        };
        return { validCols, ensure };
    }

    /* =========================
     * WHERE builder
     * ========================= */
    /**
     * Construye `WHERE` parametrizado a partir de un objeto.
     * - `null` → `IS NULL`
     * - `Array` → `IN (...)` con soporte de `NULL` dentro del array
     */
    static buildWhereClause(where = {}) {
        const clauses = [];
        const values = [];

        for (const [col, val] of Object.entries(where)) {
            if (val === undefined) continue;

            if (val === null) {
                clauses.push(`${col} IS NULL`);
                continue;
            }

            if (Array.isArray(val)) {
                const nonNulls = val.filter(v => v !== null && v !== undefined);
                const hasNull = val.some(v => v === null);
                const parts = [];

                if (nonNulls.length) {
                    parts.push(`${col} IN (${nonNulls.map(() => "?").join(", ")})`);
                    values.push(...nonNulls);
                }
                if (hasNull) parts.push(`${col} IS NULL`);

                if (parts.length) clauses.push(parts.length > 1 ? `(${parts.join(" OR ")})` : parts[0]);
                continue;
            }

            clauses.push(`${col} = ?`);
            values.push(val);
        }

        return { whereSql: clauses.join(" AND "), values };
    }

    /** Aplica alias a un objeto `where` (p. ej. `t.columna = ...`). */
    static _aliasWhere(where = {}, alias = "t") {
        const aliased = {};
        for (const [k, v] of Object.entries(where || {})) aliased[`${alias}.${k}`] = v;
        return aliased;
    }

    /* =========================
     * SELECT
     * ========================= */
    /**
     * SELECT de filas vigentes por defecto (`superado=0 AND elim=0`).
     *
     * @param {object}  opts
     * @param {object}  opts.db
     * @param {string}  opts.table
     * @param {object}  [opts.where]
     * @param {boolean} [opts.throwIfExists=false]
     * @param {string}  [opts.throwIfExistsMessage]
     * @param {boolean} [opts.throwIfNotExists=false]
     * @param {string}  [opts.throwIfNotExistsMessage]
     * @param {string|string[]} [opts.select="*"]
     * @param {boolean} [opts.log=false]
     * @returns {Promise<object[]>}
     */
    static async select({
        db,
        table,
        where = {},
        throwIfExists = false,
        throwIfExistsMessage,
        throwIfNotExists = false,
        throwIfNotExistsMessage,
        select = "*",
        log = false,
    }) {
        this._assert(isDefined(table), { title: "Parámetros inválidos", message: "Debes proporcionar 'table'." });

        if (Array.isArray(select)) {
            const { ensure } = await this._prepareColumns({ db, table, log });
            select.forEach(col => ensure(col));
        }

        const { whereSql, values } = this.buildWhereClause(where);
        const tableQ = this._quoteTable(table);
        const selectSql = this._normalizeSelect(select);

        const sql = `
      SELECT ${selectSql}
      FROM ${tableQ}
      ${whereSql ? `WHERE ${whereSql} AND superado = 0 AND elim = 0` : `WHERE 1=1 AND superado = 0 AND elim = 0`}
    `;

        const result = await executeQuery({ db, query: sql, values, log });

        if (throwIfExists && result.length > 0) {
            throw new CustomException({
                title: "Conflicto",
                message: throwIfExistsMessage ?? `Ya existe un registro en ${table} con esos valores`,
                status: Status.conflict,
            });
        }
        if (throwIfNotExists && result.length === 0) {
            throw new CustomException({
                title: "No encontrado",
                message: throwIfNotExistsMessage ?? `No se encontró registro en ${table} con los valores proporcionados`,
                status: Status.notFound,
            });
        }
        return result;
    }

    /* =========================
     * INSERT (con did = id)
     * ========================= */
    /**
     * Inserta 1..N filas. Devuelve:
     * - `number[]` con los nuevos IDs, o
     * - el **objeto insertado** si `returnRow=true` y `data` es **una sola** fila.
     *
     * Nota: siempre normaliza `quien`, `superado=0`, `elim=0` si existen en la tabla.
     */
    static async insert({
        db,
        table,
        data,
        quien,
        log = false,
        returnRow = false,
        returnSelect = "*",
    }) {
        this._assert(isDefined(table) && isDefined(data) && isDefined(quien), {
            title: "LightdataORM.insert: parámetros faltantes",
            message: "Debes proporcionar 'table', 'data' y 'quien'.",
        });

        const list = Array.isArray(data) ? data : [data];

        const { validCols, ensure } = await this._prepareColumns({
            db, table, blocklist: ["id", "did", "autofecha"], log,
        });

        for (const row of list) for (const key of Object.keys(row)) ensure(key);

        const tableQ = this._quoteTable(table);
        const placeholders = `(${validCols.map(() => "?").join(", ")})`;

        const allValues = list.map(obj =>
            validCols.map(col => {
                if (col === "quien") return quien;
                if (col === "superado") return 0;
                if (col === "elim") return 0;
                return obj[col] ?? null;
            })
        );
        const flatValues = allValues.flat();

        const insertSql = `
      INSERT INTO ${tableQ} (${validCols.map(c => this._quoteIdent(c)).join(", ")})
      VALUES ${allValues.map(() => placeholders).join(", ")};
    `;

        const inserted = await executeQuery({ db, query: insertSql, values: flatValues, log });
        this._assert(inserted?.affectedRows, {
            title: "Error al insertar",
            message: `No se pudo insertar en ${table}`,
            status: Status.internalServerError,
        });

        const firstId = Number(inserted.insertId);
        const ids = Array.from({ length: inserted.affectedRows }, (_, i) => firstId + i);

        // Normaliza did = id
        const updDidSql = `
      UPDATE ${tableQ}
      SET did = id
      WHERE id IN (${ids.map(() => "?").join(", ")});
    `;
        await executeQuery({ db, query: updDidSql, values: ids, log });

        if (!returnRow) return ids;

        if (ids.length !== 1) {
            throw new CustomException({
                title: "LightdataORM.insert",
                message: "returnRow=true requiere insertar un único registro.",
                status: Status.badRequest,
            });
        }

        const rows = await this.select({
            db,
            table,
            where: { id: ids[0] },
            select: returnSelect,
            log,
        });

        return rows?.[0] ?? null;
    }

    /* =========================
     * UPDATE (versionado)
     * ========================= */
    /**
     * Crea nuevas versiones para 1..N registros y marca vigentes previos como `superado=1`.
     * - `where[versionKey]` puede ser número o array (se aplica `IN (...)`).
     * - Si `data` es **un objeto** y hay **N ids**, se recomienda **replicarlo N veces**
     *   para alinear los `CASE WHEN` por índice.
     *
     * Retorna `number[]` (ids nuevos) o el **objeto** si `returnRow=true` y afecta exactamente 1.
     */
    static async update({
        db,
        table,
        where,
        data,
        quien,
        versionKey = "did",
        throwIfNotExists = true,
        log = false,
        returnRow = false,
        returnSelect = "*",
    }) {
        this._assert(isDefined(table) && isDefined(where) && isDefined(data) && isDefined(quien), {
            title: "LightdataORM.update: parámetros faltantes",
            message: "Debes proporcionar 'table', 'where', 'data' y 'quien'.",
        });

        const whereVal = where?.[versionKey];
        this._assert(isDefined(whereVal), {
            title: "LightdataORM.update",
            message: `Debe especificarse WHERE con la clave de versionado '${versionKey}'.`,
        });

        const idsVK = Array.isArray(whereVal)
            ? whereVal.map(Number).filter(n => Number.isFinite(n) && n > 0)
            : [Number(whereVal)];
        this._assert(idsVK.length > 0, {
            title: "LightdataORM.update",
            message: "Debe especificarse al menos un valor válido en el WHERE.",
        });

        const datas = Array.isArray(data) ? data : [data];

        const { validCols, ensure } = await this._prepareColumns({
            db, table, blocklist: ["id", "autofecha"], log,
        });

        for (const row of datas) for (const key of Object.keys(row)) ensure(key);

        const tableQ = this._quoteTable(table);

        const qSuperar = `
            UPDATE ${tableQ}
            SET superado = 1
            WHERE ${this._quoteIdent(versionKey)} IN (${idsVK.map(() => "?").join(", ")})
            AND elim = 0
            AND superado = 0;
        `;
        const updRes = await executeQuery({ db, query: qSuperar, values: idsVK, log });

        if ((!updRes || updRes.affectedRows === 0) && throwIfNotExists) {
            throw new CustomException({
                title: "Error al versionar",
                message: `No se encontró registro previo en ${table} para versionar.`,
                status: Status.notFound,
            });
        }

        const insertColumns = [...validCols];
        const selectPieces = [];
        const selectParams = [];

        for (const col of validCols) {
            if (col === versionKey) { selectPieces.push(this._quoteIdent(col)); continue; }
            if (col === "quien") { selectPieces.push("? AS quien"); selectParams.push(quien); continue; }
            if (col === "superado") { selectPieces.push("0 AS superado"); continue; }
            if (col === "elim") { selectPieces.push("0 AS elim"); continue; }

            const hasAny = datas.some(row => row[col] !== undefined);
            if (!hasAny) { selectPieces.push(this._quoteIdent(col)); continue; }

            const cases = [];
            for (let i = 0; i < idsVK.length; i++) {
                const v = datas[i]?.[col];
                if (v !== undefined) { cases.push(`WHEN ? THEN ?`); selectParams.push(idsVK[i], v); }
            }
            if (cases.length > 0) {
                selectPieces.push(`(CASE ${this._quoteIdent(versionKey)} ${cases.join(" ")} ELSE ${this._quoteIdent(col)} END) AS ${this._quoteIdent(col)}`);
            } else {
                selectPieces.push(this._quoteIdent(col));
            }
        }

        const subWhere = `${this._quoteIdent(versionKey)} IN (${idsVK.map(() => "?").join(", ")}) AND elim=0`;
        const valuesSub = [...idsVK];

        const baseSelect = `
      SELECT t.*
      FROM ${tableQ} t
      JOIN (
        SELECT ${this._quoteIdent(versionKey)}, MAX(id) AS max_id
        FROM ${tableQ}
        WHERE ${subWhere}
        GROUP BY ${this._quoteIdent(versionKey)}
      ) m ON m.${this._quoteIdent(versionKey)} = t.${this._quoteIdent(versionKey)} AND t.id = m.max_id
    `;

        const qInsert = `
      INSERT INTO ${tableQ} (${insertColumns.map(c => this._quoteIdent(c)).join(", ")})
      SELECT ${selectPieces.join(", ")}
      FROM (${baseSelect}) AS base
    `;

        const inserted = await executeQuery({
            db,
            query: qInsert,
            values: [...selectParams, ...valuesSub],
            log,
        });

        if ((!inserted || inserted.affectedRows === 0) && throwIfNotExists) {
            throw new CustomException({
                title: "Error al versionar",
                message: `No se pudo insertar nueva versión en ${table}.`,
                status: Status.internalServerError,
            });
        }

        const firstId = Number(inserted?.insertId);
        const idsNew =
            inserted && typeof inserted.affectedRows === "number" && Number.isFinite(firstId)
                ? Array.from({ length: inserted.affectedRows }, (_, i) => firstId + i)
                : [];

        if (!returnRow) return idsNew;

        if (idsNew.length !== 1) {
            throw new CustomException({
                title: "LightdataORM.update",
                message: "returnRow=true requiere afectar exactamente un registro.",
                status: Status.badRequest,
            });
        }

        const rows = await this.select({
            db,
            table,
            where: { id: idsNew[0] },
            select: returnSelect,
            log,
        });

        return rows?.[0] ?? null;
    }

    /* =========================
     * DELETE (versionado lógico)
     * ========================= */
    /**
     * Elimina lógicamente: marca vigente como `superado=1` y crea nueva versión con `elim=1`.
     * Si no hay filas vigentes, no inserta versión de eliminación (a menos que cambies la lógica).
     */
    static async delete({
        db,
        table,
        where,
        quien,
        versionKey = "did",
        throwIfNotFound = false,
        log = false,
    }) {
        this._assert(isDefined(table) && isDefined(where) && isDefined(quien), {
            title: "LightdataORM.delete: parámetros faltantes",
            message: "Debes proporcionar 'table', 'where' y 'quien'.",
        });

        const { whereSql, values } = this.buildWhereClause(where);
        this._assert(isDefined(whereSql), {
            title: "LightdataORM.delete",
            message: "Debe especificarse una condición WHERE válida.",
        });

        const { validCols } = await this._prepareColumns({
            db, table, blocklist: ["id", "autofecha"], log,
        });
        const tableQ = this._quoteTable(table);

        const qUpdate = `
      UPDATE ${tableQ}
      SET superado = 1
      WHERE ${whereSql}
      AND superado = 0 AND elim = 0;
    `;
        const updRes = await executeQuery({ db, query: qUpdate, values, log });

        if (throwIfNotFound && (!updRes || updRes.affectedRows === 0)) {
            throw new CustomException({
                title: "No encontrado",
                message: `No se encontró registro vigente para eliminar en ${table}.`,
                status: Status.notFound,
            });
        }

        if (updRes?.affectedRows > 0) {
            const aliasedWhere = this._aliasWhere(where, "t");
            const { whereSql: whereSqlT, values: valuesT } = this.buildWhereClause(aliasedWhere);

            const insertCols = [...validCols];
            const selectCols = validCols.map(c => {
                if (c === "elim") return "1 AS elim";
                if (c === "quien") return "? AS quien";
                if (c === "superado") return "0 AS superado";
                return this._quoteIdent(c);
            });

            const baseActive = `
        SELECT t.*
        FROM ${tableQ} t
        JOIN (
          SELECT ${this._quoteIdent(versionKey)}, MAX(id) AS max_id
          FROM ${tableQ}
          WHERE elim = 0
          GROUP BY ${this._quoteIdent(versionKey)}
        ) m
          ON m.${this._quoteIdent(versionKey)} = t.${this._quoteIdent(versionKey)}
         AND t.id = m.max_id
        WHERE ${whereSqlT}
      `;

            const qInsert = `
        INSERT INTO ${tableQ} (${insertCols.map(c => this._quoteIdent(c)).join(", ")})
        SELECT ${selectCols.join(", ")}
        FROM (${baseActive}) AS base;
      `;

            await executeQuery({
                db,
                query: qInsert,
                values: [quien, ...valuesT],
                log,
            });
        }
    }

    /* =========================
     * UPSERT
     * ========================= */
    /**
     * Si existe según `where` → `update` por `versionKey`.
     * Si no existe → `insert`.
     *
     * Comportamiento con múltiples coincidencias:
     * - Se recolectan **todos** los `versionKey` encontrados.
     * - Si `data` es un único objeto y hay varios `versionKey`, se replica (`broadcast`) para
     *   mantener correspondencia 1:1 en los `CASE WHEN`.
     */
    static async upsert({
        db,
        table,
        where,
        data,
        quien,
        versionKey = "did",
        log = false,
        returnRow = false,
        returnSelect = "*",
    }) {
        const existing = await this.select({
            db,
            table,
            where,
            select: [versionKey],
            log,
        });

        if (existing.length > 0) {
            const idsVK = existing
                .map(r => Number(r[versionKey]))
                .filter(n => Number.isFinite(n) && n > 0);

            const payload = Array.isArray(data) ? data : Array(idsVK.length).fill(data);

            return await this.update({
                db,
                table,
                where: { [versionKey]: idsVK },
                data: payload,
                quien,
                versionKey,
                log,
                returnRow,
                returnSelect,
            });
        }

        return await this.insert({
            db,
            table,
            data,
            quien,
            log,
            returnRow,
            returnSelect,
        });
    }
}
