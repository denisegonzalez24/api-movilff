import { logRed, logYellow } from '../../functions/logs_custom.js';
// execute_query_from_pool.js
import { format as sqlFormat } from 'mysql2'; // SOLO para logs
// importa tus logs
// import { logYellow, logRed } from './logsCustom.js';

const isBindable = (v) =>
    v === null ||
    v === undefined ||
    typeof v === 'string' ||
    typeof v === 'number' ||
    typeof v === 'boolean' ||
    v instanceof Date ||
    Buffer.isBuffer(v);

const toLogVal = (v) => {
    if (isBindable(v)) return v;
    // evita JSON.stringify en objetos (pueden ser circulares)
    return `[${v?.constructor?.name || typeof v}]`;
};

export async function executeQueryFromPool({ pool, query, values = [], log = false }) {
    if (!Array.isArray(values)) values = [values];

    // Validación temprana: si hay no-bindables, es bug del caller
    if (!values.every(isBindable)) {
        const types = values.map((v) => v?.constructor?.name || typeof v);
        const msg = `Parámetros no válidos para SQL: ${types.join(', ')}`;
        if (log) logRed(msg);
        throw new TypeError(msg);
    }

    if (log) {
        try {
            logYellow(`SQL: ${sqlFormat(query, values.map(toLogVal))}`);
        } catch {
            // fallback ultra-seguro
            logYellow(`SQL: ${query}  values(types)= ${values.map((v) => typeof v).join(', ')}`);
        }
    }

    // API promise: devuelve [rows, fields]
    const [rows] = await pool.execute(query, values);
    if (log) {
        logYellow('SQL ejecutada correctamente');
        logYellow(`Resultados: ${JSON.stringify(rows)}`);
    }
    return rows;
}
